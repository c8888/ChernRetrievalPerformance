(* Mathematica Package *)
(* Created by Mathematica Plugin for IntelliJ IDEA *)

(* :Title: Space2D *)
(* :Context: Space2D` *)
(* :Author: c8888 *)
(* :Date: 2017-11-19 *)

(* :Package Version: 0.1 *)
(* :Mathematica Version: *)
(* :Copyright: (c) 2017 c8888 *)
(* :Keywords: *)
(* :Discussion: Here all spatial structures are created. *)

BeginPackage["Space2D`"]
(* Exported symbols added here with SymbolName::usage *)

elementaryCell2D::usage =
    "elementaryCell2D[xmin_, xmax_, ymin_, ymax_, \[Delta]x_, \[Delta]y_] Constructs 2D table with point coordinates for elementary cell.
    Should me matched perfectly with a chosen wave function."

connect2DElementaryCells::usage =
    "connect2DElementaryCells[numCellsX_, numCellsY_, elementaryCell2DValues_] connects elementary cells and constructs
    table with (2numCellsX + 1) times (2numCellsY + 1) cells."

addSupportRectAndDimensionalize::usage =
    "addSupportRectAndDimensionalize[connect2DElementaryCellsTable_, marginSizeMinPercentageX_, marginSizeMinPercentageY_]:
    connect2DElementaryCellsTable - 2D array that will be padded with support
    marginSizeMinPercentageX - minimal size of total padding in percent of current size in x
    marginSizeMinPercentageY - minimal size of total padding in percent of current size in y

    This function returns new array space2DProbingPoints of size 2^N1 times 2^N2 where N1, N2 are the smallest integers with which new array
    can include old array and the minimal margins in x and y, respectively. "

mirror2DSpace::usage =
    "mirror2DSpace[FT0] mirrors the 2Dtable with respect to {0,0} coordinate. Corners come to the middle and vice versa."

elementaryCell2DNodes::usage =
    "elementaryCell2DNodes[elementaryCellXYTable_, nodesExactPositions_] takes an elementary cell table with x y coordinates and a list of lattice nodes and
    returns a list {..., {{i,j}, deltax_ij}_k, ...} where i,j are the approximate indices in elementaryCellXYTable of node nodesExactPositions[[k]]. "

fullSpace2DNodes::usage =
    "fullSpace2DNodes[elementaryCell2DNodes_, elementaryCellXYTable_, numCellsX_, numCellsY_] takes a list generated by elementaryCell2DNodes[elementaryCellXYTable_, nodesExactPositions_],
      and elementaryCellXYTable and number of cells in x and y direction and returns positions along with distances from real node in table WITHOUT support;
      nodesTranslateAfterDimensionalizing[fullSpace2DNodes_, oldDims_, newDims_] should be used after adding support."

nodesTranslateAfterDimensionalizing::usage =
    "nodesTranslateAfterDimensionalizing[fullSpace2DNodes_, oldDims_, newDims_] translates nodes when support is added to match new table.
     CenterArray documentation tells that 'If the amount of padding is an odd number, additional padding is placed on the right', so in implementation we use Floor"

nodesNeighbourhood::usage =
    "nodesNeighbourhood[fullSpace2DNodes_, \[Delta]x_, \[Delta]y_, rangeRectangleSizeX_, rangeRectangleSizeY_, dimsArray_] takes nodes as argument
    and creates array that contains indices of vortices of the rectangle of given size around each node. Vide lab notebook p.26"

normalise2DArray::usage =
    "normaliseArray[array_, \[Delta]x_, \[Delta]y_] normalises a 2D array assuming spacings between probing points are dx, dy"

connectAndTranslate2DElementaryCells::usage =
    "connectAndTranslate2DElementaryCells[numCellsX_, numCellsY_, elementaryCell2DValues_] creates lattice probing points list from elementary cell"


Begin["`Private`"]

elementaryCell2D[xmin_, xmax_, ymin_, ymax_, \[Delta]x_, \[Delta]y_]:=
    Table[{x,y}, {x, N@xmin, N@xmax, N@\[Delta]x}, {y, N@ymin, N@ymax, N@\[Delta]y}]

latticeProbingPointsBZ[npts_, a_, q_]:=
    Module[
      { (*we assume p=1 in p/q*2Pi flux*)
        dkx = 2 Pi/(q * a) /npts,
        dky = 2 Pi/a/npts
      },
      N@Table[{kx, ky}, {kx, 0, dkx*npts, dkx}, {ky, 0, dky*npts, dky}]
    ]

connect2DElementaryCells[numCellsX_, numCellsY_, elementaryCell2DValues_]:=
     Return@Transpose@Flatten[Table[Transpose[Flatten[Table[elementaryCell2DValues[[1;;-2, 1;;-2]], 2 numCellsX + 1], 1]], 2 numCellsY + 1], 1];

connectAndTranslate2DElementaryCells[numCellsX_, numCellsY_, elementaryCell2DValues_, \[Delta]x_, \[Delta]y_]:=
    Module[
      {
        deltaR =  {Max[elementaryCell2DValues[[All, All, 1]]] - Min[elementaryCell2DValues[[All, All, 1]]], Max[elementaryCell2DValues[[All, All, 2]]] - Min[elementaryCell2DValues[[All, All, 2]]]}
      },
      Return@Transpose@Flatten[Table[Transpose[Flatten[Table[Map[{i,j} deltaR + #&, elementaryCell2DValues[[1;;-2, 1;;-2]], {2}], {i, -numCellsX, numCellsX}], 1]], {j, -numCellsY, numCellsY}], 1]
]


addSupportRectAndDimensionalize[connect2DElementaryCellsTable_, marginSizeMinPercentageX_, marginSizeMinPercentageY_]:=
    Module[
      {
        dims = Dimensions[connect2DElementaryCellsTable][[1;;2]],
        newDims,
        N1=0,
        N2=0
      },
      newDims = Floor[{1 + marginSizeMinPercentageX / 100, 1 + marginSizeMinPercentageY / 100 } * dims];

      While[2^N1 <= newDims[[1]], N1++];
      newDims[[1]] = 2^(N1);

      While[2^N2 <= newDims[[2]], N2++];
      newDims[[2]] = 2^(N2);

      Return@CenterArray[connect2DElementaryCellsTable, newDims];
    ]

elementaryCell2DNodes[elementaryCellXYTable_, nodesExactPositions_]:=
    Module[
      {
        deltaXPeakExactTable, (* distane from probed point to exact node position *)
        indexTable
      },
      indexTable = Map[First@Position[elementaryCellXYTable, First@Nearest[Flatten[elementaryCellXYTable, 1], #]]&, nodesExactPositions, {1}];
      deltaXPeakExactTable = nodesExactPositions - Map[elementaryCellXYTable[[#[[1]], #[[2]]]] &, indexTable, {1}];
      Return[Transpose@{indexTable, deltaXPeakExactTable}];
    ]

fullSpace2DNodes[elementaryCell2DNodes_, elementaryCellXYTable_, numCellsX_, numCellsY_]:=
    Module[
      {
        elCellDims = Dimensions[elementaryCellXYTable][[1;;2]] - 1
      },

      Return@Flatten[Map[
        Flatten[Table[{#[[1]] + {n, m}*elCellDims, #[[2]]}, {n, 0,
          2 numCellsX }, {m, 0, 2 numCellsY}], 1] &,
        elementaryCell2DNodes, {1}], 1];
    ]

nodesTranslateAfterDimensionalizing[fullSpace2DNodes_, oldDims_, newDims_]:=
    Module[
      {
        deltaDims = 1/2(newDims - oldDims)
      },
      Return@Map[{#[[1]] + Floor@deltaDims, #[[2]]}&, fullSpace2DNodes, {1}]
    ]

nodesNeighbourhood[fullSpace2DNodes_, \[Delta]x_, \[Delta]y_, rangeRectangleSizeX_, rangeRectangleSizeY_, dimsArray_]:=
    Return@Map[{Max/@Transpose@{#[[1]] - Round[{rangeRectangleSizeX/2, rangeRectangleSizeY/2}/{\[Delta]x, \[Delta]y}] , {1,1} },
      Min/@Transpose@{#[[1]] + Round[{rangeRectangleSizeX/2, rangeRectangleSizeY/2}/{\[Delta]x, \[Delta]y}] , dimsArray} } &,
      fullSpace2DNodes, {1}
    ]

normalise2DArray[array_, \[Delta]x_, \[Delta]y_]:=
    Return[
      array/Sqrt[Total[Total[Abs[array]^2]] * \[Delta]x * \[Delta]y]
    ]

mirror2DSpace[FT0_] :=
    Module[{
      FT = FT0,
      nCol = Dimensions[FT0][[1]],
      nRow = Dimensions[FT0][[2]],
      ret,
      firstQuad,
      secondQuad,
      thirdQuad,
      fourthQuad},
    (* read quads *)

      firstQuad = FT[[1 ;; Floor[0.5*nCol], 1 ;; Floor[0.5*nRow]]];
      secondQuad = FT[[1 ;; Floor[0.5*nCol], Floor[0.5*nRow] + 1 ;; nRow]];
      thirdQuad =
          FT[[Floor[0.5*nCol] + 1 ;; nCol, 1 ;; Floor[0.5*nRow]]];
      fourthQuad =
          FT[[Floor[0.5*nCol] + 1 ;; nCol, Floor[0.5*nRow] + 1 ;; nRow]];

      (* Mirror *)
      firstQuad = Reverse[Reverse[firstQuad], 2];
      secondQuad = Reverse[Reverse[secondQuad], 2];
      thirdQuad = Reverse[Reverse[thirdQuad], 2];
      fourthQuad = Reverse[Reverse[fourthQuad], 2];

      (* Take back together and return *)
      ret = Table[
        Which[
          i <= Floor[0.5*nCol] && j <= Floor[0.5*nRow], firstQuad[[i, j]],
          i <= Floor[0.5*nCol] && j > Floor[0.5*nRow],
          secondQuad[[i, j - Floor[0.5*nRow]]],
          i > Floor[0.5*nCol] && j <= Floor[0.5*nRow],
          thirdQuad[[i - Floor[0.5*nCol], j]],
          i > Floor[0.5*nCol] && j > Floor[0.5*nRow],
          fourthQuad[[i - Floor[0.5*nCol], j - Floor[0.5*nRow]]]
        ],
        {i, nCol}, {j, nRow}
      ]
    ]



End[] (* `Private` *)

EndPackage[]